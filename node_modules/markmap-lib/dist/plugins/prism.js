"use strict";

exports.__esModule = true;
exports.plugin = void 0;

var _util = require("../util");

const errors = {};
const styles = [{
  type: 'stylesheet',
  data: {
    href: 'https://cdn.jsdelivr.net/npm/prismjs@1/themes/prism.css'
  }
}];
const scripts = [{
  type: 'iife',
  data: {
    fn: () => {
      window.Prism = {
        manual: true
      };
    }
  }
}, {
  type: 'script',
  data: {
    src: 'https://cdn.jsdelivr.net/npm/prismjs@1/components/prism-core.min.js'
  }
}, // components will be added by paths relative to path of autoloader
{
  type: 'script',
  data: {
    src: 'https://cdn.jsdelivr.net/npm/prismjs@1/plugins/autoloader/prism-autoloader.min.js'
  }
}];

function initialize(Markmap, options) {
  Markmap.transformHtml.tap((mm, nodes) => {
    const {
      Prism
    } = window;
    const langs = (0, _util.flatMap)(nodes, node => (0, _util.arrayFrom)(node.querySelectorAll('code[class*=language-]'))).map(code => {
      const lang = code.className.match(/(?:^|\s)language-(\S+)|$/)[1];

      if (Prism.languages[lang]) {
        Prism.highlightElement(code);
      } else if (!errors[lang]) {
        return lang;
      }
    }).filter(Boolean);
    loadLanguagesAndRender(mm, langs);
  });
}

async function loadLanguagesAndRender(mm, langs) {
  if (!langs.length) return;
  const {
    Prism
  } = window;

  try {
    await new Promise((resolve, reject) => {
      Prism.plugins.autoloader.loadLanguages(langs, resolve, reject);
    });
  } catch (err) {
    errors[err] = true;
  }

  mm.setData();
  mm.fit();
}

const plugin = {
  styles,
  scripts,
  initialize
};
exports.plugin = plugin;